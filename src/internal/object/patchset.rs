//! AI PatchSet Definition
//!
//! A `PatchSet` represents a proposed set of code changes (diffs) generated by an agent.
//!
//! # Generations
//!
//! PatchSets are often created in generations (iterations).
//! If a PatchSet fails validation or code review, the agent may generate a new PatchSet (generation N+1)
//! for the same `Run`.
//!
//! # Content
//!
//! The actual diff content is stored as an `ArtifactRef` (e.g., pointing to a file in object storage),
//! while `TouchedFile` provides a lightweight summary for UI/indexing.

use std::fmt;

use serde::{Deserialize, Serialize};
use uuid::Uuid;

use crate::{
    errors::GitError,
    hash::ObjectHash,
    internal::object::{
        ObjectTrait,
        integrity::IntegrityHash,
        types::{ActorRef, ArtifactRef, Header, ObjectType},
    },
};

/// Patch application status.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ApplyStatus {
    /// Patch is generated but not yet applied to the repo.
    Proposed,
    /// Patch has been applied (committed) to the repo.
    Applied,
    /// Patch was rejected by validation or user.
    Rejected,
    /// A newer generation has replaced this patch.
    Superseded,
}

impl ApplyStatus {
    pub fn as_str(&self) -> &'static str {
        match self {
            ApplyStatus::Proposed => "proposed",
            ApplyStatus::Applied => "applied",
            ApplyStatus::Rejected => "rejected",
            ApplyStatus::Superseded => "superseded",
        }
    }
}

impl fmt::Display for ApplyStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// Diff format for patch content.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum DiffFormat {
    /// Standard unified diff format.
    UnifiedDiff,
    /// Git-specific diff format (with binary support etc).
    GitDiff,
}

/// Type of change for a file.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ChangeType {
    Add,
    Modify,
    Delete,
    Rename,
    Copy,
}

/// Touched file summary in a patchset.
///
/// Provides a quick overview of what files are modified without parsing the full diff.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TouchedFile {
    pub path: String,
    pub change_type: ChangeType,
    pub lines_added: u32,
    pub lines_deleted: u32,
}

impl TouchedFile {
    pub fn new(
        path: impl Into<String>,
        change_type: ChangeType,
        lines_added: u32,
        lines_deleted: u32,
    ) -> Result<Self, String> {
        let path = path.into();
        if path.trim().is_empty() {
            return Err("path cannot be empty".to_string());
        }
        Ok(Self {
            path,
            change_type,
            lines_added,
            lines_deleted,
        })
    }
}

/// PatchSet object containing a candidate diff.
/// Each generation represents a new candidate diff for the same run.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PatchSet {
    #[serde(flatten)]
    header: Header,
    run_id: Uuid,
    generation: u32,
    base_commit_sha: IntegrityHash,
    diff_format: DiffFormat,
    diff_artifact: Option<ArtifactRef>,
    #[serde(default)]
    touched_files: Vec<TouchedFile>,
    #[serde(default)]
    supersedes_patchset_ids: Vec<Uuid>,
    rationale: Option<String>,
    apply_status: ApplyStatus,
}

impl PatchSet {
    /// Create a new patchset object
    pub fn new(
        repo_id: Uuid,
        created_by: ActorRef,
        run_id: Uuid,
        base_commit_sha: impl AsRef<str>,
        generation: u32,
    ) -> Result<Self, String> {
        let base_commit_sha = base_commit_sha.as_ref().parse()?;
        Ok(Self {
            header: Header::new(ObjectType::PatchSet, repo_id, created_by)?,
            run_id,
            generation,
            base_commit_sha,
            diff_format: DiffFormat::UnifiedDiff,
            diff_artifact: None,
            touched_files: Vec::new(),
            supersedes_patchset_ids: Vec::new(),
            rationale: None,
            apply_status: ApplyStatus::Proposed,
        })
    }

    pub fn header(&self) -> &Header {
        &self.header
    }

    pub fn run_id(&self) -> Uuid {
        self.run_id
    }

    pub fn generation(&self) -> u32 {
        self.generation
    }

    pub fn base_commit_sha(&self) -> &IntegrityHash {
        &self.base_commit_sha
    }

    pub fn diff_format(&self) -> &DiffFormat {
        &self.diff_format
    }

    pub fn diff_artifact(&self) -> Option<&ArtifactRef> {
        self.diff_artifact.as_ref()
    }

    pub fn touched_files(&self) -> &[TouchedFile] {
        &self.touched_files
    }

    pub fn supersedes_patchset_ids(&self) -> &[Uuid] {
        &self.supersedes_patchset_ids
    }

    pub fn rationale(&self) -> Option<&str> {
        self.rationale.as_deref()
    }

    pub fn apply_status(&self) -> &ApplyStatus {
        &self.apply_status
    }

    pub fn set_diff_artifact(&mut self, diff_artifact: Option<ArtifactRef>) {
        self.diff_artifact = diff_artifact;
    }

    pub fn add_touched_file(&mut self, file: TouchedFile) {
        self.touched_files.push(file);
    }

    pub fn set_rationale(&mut self, rationale: Option<String>) {
        self.rationale = rationale;
    }

    pub fn set_apply_status(&mut self, apply_status: ApplyStatus) {
        self.apply_status = apply_status;
    }

    pub fn add_supersedes_patchset_id(&mut self, patchset_id: Uuid) {
        self.supersedes_patchset_ids.push(patchset_id);
    }

    pub fn set_supersedes_patchset_ids(&mut self, patchset_ids: Vec<Uuid>) {
        self.supersedes_patchset_ids = patchset_ids;
    }

    pub fn validate_supersedes(&self) -> Result<(), GitError> {
        if self
            .supersedes_patchset_ids
            .contains(&self.header.object_id())
        {
            return Err(GitError::InvalidPatchSetObject(
                "PatchSet cannot supersede itself".to_string(),
            ));
        }
        Ok(())
    }
}

impl fmt::Display for PatchSet {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "PatchSet: {}", self.header.object_id())
    }
}

impl ObjectTrait for PatchSet {
    fn from_bytes(data: &[u8], _hash: ObjectHash) -> Result<Self, GitError>
    where
        Self: Sized,
    {
        serde_json::from_slice(data).map_err(|e| GitError::InvalidObjectInfo(e.to_string()))
    }

    fn get_type(&self) -> ObjectType {
        ObjectType::PatchSet
    }

    fn get_size(&self) -> usize {
        match serde_json::to_vec(self) {
            Ok(v) => v.len(),
            Err(e) => {
                tracing::warn!("failed to compute PatchSet size: {}", e);
                0
            }
        }
    }

    fn to_data(&self) -> Result<Vec<u8>, GitError> {
        serde_json::to_vec(self).map_err(|e| GitError::InvalidObjectInfo(e.to_string()))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_hash_hex() -> String {
        IntegrityHash::compute(b"ai-process-test").to_hex()
    }

    #[test]
    fn test_patchset_creation() {
        let repo_id = Uuid::from_u128(0x0123456789abcdef0123456789abcdef);
        let actor = ActorRef::agent("test-agent").expect("actor");
        let run_id = Uuid::from_u128(0x1);
        let base_hash = test_hash_hex();

        let patchset = PatchSet::new(repo_id, actor, run_id, &base_hash, 1).expect("patchset");

        assert_eq!(patchset.header().object_type(), &ObjectType::PatchSet);
        assert_eq!(patchset.generation(), 1);
        assert_eq!(patchset.diff_format(), &DiffFormat::UnifiedDiff);
        assert_eq!(patchset.apply_status(), &ApplyStatus::Proposed);
        assert!(patchset.touched_files().is_empty());
        assert!(patchset.supersedes_patchset_ids().is_empty());
    }

    #[test]
    fn test_patchset_validate_supersedes_self_reference() {
        let repo_id = Uuid::from_u128(0x0123456789abcdef0123456789abcdef);
        let actor = ActorRef::agent("test-agent").expect("actor");
        let run_id = Uuid::from_u128(0x1);
        let base_hash = test_hash_hex();

        let mut patchset =
            PatchSet::new(repo_id, actor, run_id, &base_hash, 1).expect("patchset");
        let self_id = patchset.header().object_id();
        patchset.add_supersedes_patchset_id(self_id);

        let err = patchset.validate_supersedes().expect_err("should be invalid");
        match err {
            GitError::InvalidPatchSetObject(msg) => {
                assert!(msg.contains("supersede"), "unexpected message: {msg}");
            }
            other => panic!("unexpected error: {other}"),
        }
    }
}
